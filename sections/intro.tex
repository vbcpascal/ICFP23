\section{Introduction}

Language-oriented programming (LOP) \cite{LOP} features solving a class of problems by designing one or more new domain-specific languages (DSLs).
To avoid reimplementing common language constructs like loops and branches,
developers tend to implement DSLs based on another general-purpose programming language (called host language).
Developers can define a DSL based on the language features of the host language, rendering programs with domain-specific forms.
Languages with features like macros and higher-order functions are frequently employed\cite{macro-dsl,macro-dsl-2}.
These features can be treated as methods to implement translations from DSLs to the host language.
By specifying translation rules from the DSL to the host language, developers can obtain a DSL interpreter naturally.
This type of DSL is called embedded DSL (eDSL).

Despite eDSL can significantly reduce implementation efforts, DSL users find it inconvenient because of the inevitable need to learn the concepts of host language and understand error messages.
This problem is called \textit{abstraction leakage} \cite{Abstraction},
 which means the users writes a DSL program which is translated into the host language,
 causing the executed program pretty differently from the original program.

Pombrio et al. have made a great progress in maintenance of abstraction automatically for syntactic sugars.
They proposed \textit{resugaring} \cite{resugar}, by selectively reorganizing the sequence of evaluations on the host language to the DSL according to the reverse translation rules.
% In particular, a DSL program is translated into host language first.
% Then, each term in the evaluation sequence of the host language is checked if it can be reconstructed into the DSL constructs dynamically.
However, the error still appears in the host language, which cannot be lifted to DSL.
DSL users can only observe that the evaluation sequence is stuck, but do not know why. 
Type lifting \cite{infer-types} is another work on abstraction.
The type system of DSL is inferred statically according to the translation rules and typing rules of the host language.
Then, these inferred typing rules of DSL can guide DSL users,
 and facilitates the generation of high-quality DSL error messages.

Inspired by these work, we expect to lift the semantics of DSL, to overcome drawbacks of resugaring.
The DSL develops only need to provide the translation rules from the DSL to the host language.
We then automatically derive evaluation rules of the DSL constructs based on the semantics of the host language and translation rules for DSL definition.
These new semantics can be used as documentation for the DSL,
 and give the user a better aid in diagnosis when the DSL program is stuck.
We call this \textit{semantics lifting}.
In other words, for a DSL construct defined by translation rule, we would like to \textit{derive its evaluation rule}.
We adapt the core ideas of typing rules derivation to semantics lifting.
For example, in a host language with lambda abstraction and application, we can define $\<let>$ by a transformation:
\[ \<let>~x:t=e_1~\<in>~e_2 => (位x:t.e_2)~e_1 \]

% We expect to make the DSL standalone --- statically deriving the semantics for DSL constructs defined by translation rules.
% The major change is that, in general, 
%  embedded DSLs treat the host language as a black box,
%  while we take the definition of the host language as a white box.
% The general-purpose programming language used as host language should be carefully designed.
% Then, many DSLs can be defined by translation rules on the host language, as shown in Fig. \ref{fig:layers}.
% Our focus, highlighted in Fig. \ref{fig:layers}, is to \textit{lift} the definition (semantics and typing rules) of the host language to the DSLs,
%  which refers the derivation of the definition of DSLs from the host language definition and translation rules.

% That is, the definition can be understood by DSL users,
%  without requirement for host language knowledge.
% Previous work \cite{infer-types} has given methods for statically inferring typing rules.
% And we will contribute to the semantics lifting.



% To this end, we describe the evaluation rules of the host language through a \textit{meta-language}.
% And the derived rules of the DSL is presented through meta-language as well.
% As a first step, the static derivation of semantics and typing rules for DSLs is called language lifting.
% We follow the core ideas of inferring typing rules for syntactic sugars \cite{infer-types} and apply it to semantics.
% For example, in a host language with lambda abstraction and application, we can define $\<let>$ by translation rule:
% \[ e_1~\<and>~e_2 => \<if>~e_1~\<then>~e_2~\<else>~\<false>. \]
% The derivation of $\<and>$ is given in Fig. \ref{fig:and}.

The evaluation rule derivation of $\<let>$ is given in Fig. \ref{fig:let}.
An expression with $\<let>$ evaluates to $v$ in DSL,
 iff the translated problem evaluates to $v$ in host language (Step 1).
Based on the evaluation rule of application, we can futher expand the premise (Step 2).
A lambda abstraction is always a value, with no premises (Step 3). 
% And the evaluation rule of lambda abstraction can be applied.
Hence, we can obtain the following evaluation rule for $\<let>$:
\[
  \inference{e_1 \Da v_1 & e_2[v_1/x] \Da v}{\<let>~x:t=e_1~\<in>~e_2 \Da v}
\]
Note that without lambda abstraction and application appearing in the premises,
 the evaluation rule of $\<let>$ is described directly.
We define \textit{abstraction} property as evaluation rules of DSL should be independent of the host language.
And the abstraction property holds.

\begin{figure}[t!]
  \[
    \inference[(Step 1) ]{%
      \inference[(Step 2) ]{%
        \inference[(Step 3)]{}{%
          位x:t.e_2 \Da 位x:t.e_2}
        & e_1 \Da v_1
        & e_2[v_1/x] \Da v
      }
      {(位x:t.e_2)~e_1 \Da v}
    }
    {\<let>~x:t=e_1~\<in>~e_2 \Da v}
  \]
  \caption{Evaluation Rule Derivation of $\mathit{let}$}
  \label{fig:let}
\end{figure}

This approach is seemingly natural but we are facing some challenges:
(1) In most cases it is not possible to statically determine where the lambda abstraction is called,
 and thus it is not possible to statically evaluate the abstraction body part directly.
 When a lambda abstraction is used in a translation rule for DSL constructs definition,
 the evaluation of inner language construct is delayed until that lambda abstraction is called in the DSL.
 Therefore, lambda abstraction with host language constructs may lead to abstraction leakage.
(2) The evaluation rules of applications and let bindings contain the evaluation of substitution like $e[v/x]$.
 In the derivation, $e$ may be replaced by some compound expression.
 We affect to carefully consider the relationship between the scope of $x$ and $e$ in order to prevent hygiene problems.
 Therefore, we need to expand this part of the evaluation to maintain abstractness while ensuring correctness.
(3) When deriving rules, we recursively generate premises based on the evaluation rules of language constructs.
 However, the evaluation of many language constructs, like $\<if>$, is determined by multiple rules.
 This may lead to nondeterminacy when applying rules in derivation.

To address challenge (1),
 we propose \textit{lambda exposure} transformation for translation rules,
 to reveal the body of abstraction.
To address challenge (2),
 we first impose strict requirements on translation rules to avoid hygienic problems and ensure correctness,
 and second show that applying substitution rules statically maintains abstractness.
To address challenge (3),
 we introduce Skeletal semantics to describe the behaviour of language constructs \cite{skeleton}.
 Each language construct has a unique rule, which guarantees the determinacy in derivation.
 We use Skeleton as the meta-language and implement semantic lifting by deriving Skeletons for DSL constructs.

Defining DSLs by translation rules allow developers to specialize the DSL constructs on the host language.
% Based on semantics lifting, the abstraction of DSL can be maintained.
Combined with the existing work on type lifting, we can automatically derive evaluation and typing rules for DSLs.
The language lifting is, generating the definitions of DSLs (evaluation and typing rules) from the definition of the host language and translation rules,
 with abstraction property maintained, shown in Fig. \ref{fig:layers}.
DSLs are host language independent, which can be standalone.

\begin{figure}[t]
  \input{assets/layers.tikz}
  \caption{Language Lifting}
  \label{fig:layers}
\end{figure}

But sometimes DSL cannot be defined by translation rules in an existing host language.
To solve this problem, when the expressiveness of the host language is insufficient, 
 our framework provides meta-extensions (to introduce new vocabularies) and monad-extensions (to introduce side effects) on the host language
 to extend language without changing original semantics.
To describe the evaluation after monad extensions, we add monad support to the meta-language.
DSL developers can specialize the DSL constructs based on this extended host language.
We consider this to be a generic DSL design pattern:
 various languages containing different features are extended from the host language,
 and the DSL developers select the appropriate host language and define the DSLs by translation rules.
In this paper, we use simply-typed lambda-calculus (\STLC) as the basic host language.

Our main technical contributions can be summarized as follows:

\begin{itemize}
  % \item We design a meta-language to describe the evaluation rules and typing rules of a language structurally.
  %   % The meta-language can be extended in a modular way.
  %   We formalize the syntax and semantics of our meta-language (Section \ref{sec:meta}).
  %   And then, we define the host language \STLC{} using meta-language (Section \ref{sec:m-host}).
  \item We present a semantics lifting algorithm for DSL constructs defined by translation rules (Section \ref{sec:tr}).
    As major properties of the algorithm, we give proofs of correctness and abstraction. 
    % For translation rules defined with lambda abstraction,
    %  we illustrate lambda exposure algorithm to maintain abstraction property.
    % Besides, evaluation rules with substitution will not break these properties.
  \item We propose a general DSL implementation workflow, using \STLC{} as the host language:
    first introduce vocabularies by meta-extensions and new language features by monad extensions (Section \ref{sec:ex}),
    then define the DSL constructs by translation rules on the extended language.
    % For each step, we give a formal description with examples.
    % And two strict requirements will be applied to translation rules.
  % \item We present an algorithm to derive evaluation and typing rules for DSL constructs defined by translation rules (Section \ref{sec:alg}).
  %   As major properties of algorithms, we give proofs of correctness and abstraction. 
  %   For translation rules defined with lambda abstraction,
  %    we illustrate lambda exposure method to maintain abstraction property.
  %   Besides, these properties can be guaranteed with substitution in derivation.
  \item We give an implementation of the framework called Osazone (Section \ref{sec:impl}).
    We use a nontrivial example with seven language implemented (three of them are designed as DSLs) as the evidence for the power of Osazone (Section \ref{sec:eval}).
\end{itemize}

% Note that the focus of this paper is on the semantics of the language rather than the syntax. 
% Extensions to the syntax, such as parser implementation for DSLs, are not the topic of this paper.
