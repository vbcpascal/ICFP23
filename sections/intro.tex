\section{Introduction}

Language-oriented programming (LOP) \cite{LOP} is solving a class of problems by designing one or more new domain-specific languages (DSLs).
To avoid building common languages constructs like loops and branches,
developers tend to implement DSLs based on another general-purpose programming language (called host language).
Developers can define DSL based on the language features of the host language, rendering programs with domain-specific forms.
Languages with features like macros and higher-order functions are frequently employed\cite{macro-dsl,macro-dsl-2}.
These features can be treated as a method to implement translation from the DSL to the host language.
By specifying translation rules from the DSL to the host language, developers can obtain a DSL interpreter naturally.
This type of DSL is called embedded DSL (eDSL).

Despite eDSL can significantly reduce implementation costs, DSL users find it inconvenient because of the inevitable need to learn the concepts of host language and understand error messages.
This problem is called abstraction leakage \cite{Abstraction},
 which means the users writes a DSL program which is translated into the host language,
 causing the executed program pretty differently from the original program.

% Much prior work has focused on how to translate information from the host language to the DSL users manually.
% \todo{More related work about generate information manually}

Pombrio et al. \cite{resugar} have made a great progress in maintenance of abstraction automatically, for syntactic sugars.
They proposed \textit{resugaring}, by selectively reorganizing the sequence of evaluations on the host language to the DSL according to the reverse translation rules.
But it still contains a host language evaluator executing,
 which means the semantics of these DSLs depends on the host language.
Users do not have direct access to the semantics of the DSL language constructs.

% There are several practical problems in this approach.
% First, the evaluation of certain language constructs are all similar.

% But there are several practical problems in this approach.
% First, the evaluation sequence of complex programs with many syntactic sugars are pretty expensive to check whether each of them can be resugared.
% Yang et al. \cite{lazy-desg} solved this problem via lazy desugaring.
% Second, it still contains a host language evaluator executing,
%  so that users cannot intuit the functionality of language constructs.

% In this paper, we will focus on the second problem.
% In this paper, we propose a new approach to implementing DSLs by translation rules but make it standalone.

We expect to make the DSL standalone ---
 statically deriving the semantics for those defined by translation rules.
The major change is, in general, 
 embedded DSLs treat the host language as a black box,
 while we take the semantics of the host language as a white box.
The general-purpose programming language used as host language should be well-designed.
We describe the semantics of the host language through a \textit{meta-language} and 
 generate the semantics of the DSL according to the translation rules.
The core property of the derivation is abstraction:
 the evaluation rules of DSL should be host-language independent.
That is, these rules can be understood by DSL users,
 without requirement for host language knowledge.

As a first step, the static derivation of semantic and typing rules for DSLs is called language lifting.
We follow the core ideas of inferring type rules for syntactic sugars \cite{infer-types} and extend it to the semantics.
For example, in a host language with lambda abstraction and application, we can define $\<let>$ by translation rule:
\[ \<let>~x:t=e_1~\<in>~e_2 => (λx:t.e_2)~e_1 \]
% \[ e_1~\<and>~e_2 => \<if>~e_1~\<then>~e_2~\<else>~\<false>. \]
% The derivation of $\<and>$ is given in Fig. \ref{fig:and}.
The derivation of $\<let>$ is given in Fig. \ref{fig:let}.
In DSL, an expression matching the pattern of left-hand side (LHS) evaluates to $v$,
 if and only if the right-hand side (RHS) expression evaluates to $v$ (Step 1).
Based on the rules of application, we can futher expand the evaluation of RHS (Step 2).
A lambda abstraction is always a value. And the rule of lambda abstraction can be applied (Step 3).
Hence, we can obtain the following conclutions:
\[
  \inference{e_1 \Da v_1 & e_2[v_1/x] \Da v}{\<let>~x:t=e_1~\<in>~e_2 \Da v}
\]
Not that without translating into lambda abstraction and application,
 the rules describe the rules of $\<let>$ directly.
The abstraction property holds.

% \begin{figure}[t!]
%   \[
%     \inference[(Step 1) ]{%
%       \inference[(Step 2) ]{%
%         e_1 \Da \<true>
%         & e_2 \Da v
%       }
%       {\<if>~e_1~\<then>~e_2~\<else>~\<false> \Da v}
%     }
%     {e_1~\<and>~e_2 \Da v}
%     \qquad
%     \inference[(Step 1) ]{%
%       \inference[(Step 2) ]{%
%         e_1 \Da \<false>
%         & \inference[(Step 3)]{}{\<false> \Da \<false>}
%       }
%       {\<if>~e_1~\<then>~e_2~\<else>~\<false> \Da \<false>}
%     }
%     {e_1~\<and>~e_2 \Da \<false>}
%   \]
%   \caption{Derivation of $\mathbf{and}$}
%   \label{fig:and}
% \end{figure}

\begin{figure}[t!]
  \[
    \inference[(Step 1) ]{%
      \inference[(Step 2) ]{%
        \inference[(Step 3)]{}{%
          λx:t.e_2 \Da λx:t.e_2}
        & e_1 \Da v_1
        & e_2[v_1/x] \Da v
      }
      {(λx:t.e_2)~e_1 \Da v}
    }
    {\<let>~x:t=e_1~\<in>~e_2 \Da v}
  \]
  \caption{Semantic Derivation of $\mathit{let}$}
  \label{fig:let}
\end{figure}

This approach is seemingly natural but we are facing three challenges:
(1) Unlike typing rules, which can typically be stated by one single rule,
many evaluation rules, such as $\<if>$, do not conform this property:
\[ \inference{e_1\Da \<true>  & e_2\Da v_2}{\<if>~e_1~e_2~e_3\Da v_2} \quad 
   \inference{e_1\Da \<false> & e_3\Da v_3}{\<if>~e_1~e_2~e_3\Da v_3} 
\]
This may lead to nondeterminacy when searching rules in derivation. % or exponential growth in the number of rules.
(2) Most type rules are defined in a modular way,
% which means the type of an expression just depends on the types of subexpressions,
but the semantics may be not.
In particular, when using lambda calculus as the host language,
lambda abstraction itself is a value,
so that a translation rule defined by lambda abstraction is a value as well.
This may ruin the abstraction. 
For example, $\<if>$ always appears in the evaluation rule of $\<andf>$,
 which cannot be reduced:
\[ \<andf> => λx:\<bool>.~λy:\<bool>.~\<if>~x~\<then>~y~\<else>~\<false>. \]
(3) Since the rules of application include substitution,
we must specify the expansion behaviour for expressions with substitution in semantic derivation.

To address challenge (1),
we introduce a variant of Skeleton \cite{skeleton} as meta-language to describe evaluation and typing rules.
As a requirement, each language construct has unique evaluation and typing rules,
 in order to guarantee the determinacy of derivation.
To address challenge (2),
 we propose \textit{lambda lifting}, to reveal the semantics of lambda abstraction.
To address challenge (3),
 we show that under some restrictions on translation rules,
 substitution keeps the correctness and abstraction of semantic derivation.

In this paper, we propose a new framework for DSL design.
We use simply-typed lambda-calculus (\STLC) as the host language for its elementariness and versatility.
To face the various demand of language features and enhance the versatility of the framework,
 we propose a general DSL implementation flow.
Our framework provide meta-extensions (to introduce new vocabularies) and monad-extensions (to introduce side-effects) on the host language.
Then, users can specify DSL constructs by translation rules on the new extended host language.
Hence, the framework will derive the evaluation rules and typing rules for these new constructs automatically,
 to make the DSL standalone.
All these rules are described by the meta-language. % and those of DSLs are generated.
Finally and naturally, our framework will generate interpreters for DSLs based on these meta-language rules.
Our main technical contributions can be summarized as follows:

\begin{itemize}
  \item We design a meta-language to describe the evaluation rules and typing rules of a language structurally.
    The meta-language can be extended in a modular way (Section \ref{sec:meta}).
    We formalize the syntax and semantics of our meta-language.
    And then, we define the host language \STLC{} as a whitebox using meta-language (Section \ref{sec:m-host}).
  \item We propose a general DSL implementation flow, using \STLC{} as the host language:
    first introduce vocabularies by meta-extensions and new language features by monad extensions,
    then define the DSL constructs by translation rules on the extended language (Section \ref{sec:dsl}). 
    For each step, we give a formal description with examples.
    And two strict requirements will be applied to translation rules.
  \item We present an algorithm to derive evaluation and typing rules for DSL constructs defined by translation rules (Section \ref{sec:alg}).
    As major properties of algorithms, we give proofs of correctness and abstraction. 
    For translation rules defined with lambda abstraction,
     we illustrate lambda lifting method to maintain abstraction property.
    Besides, these properties can be guaranteed with substitution in derivation.
  \item We give an implementation of the framework called Osazone (Section \ref{sec:impl}).
    We use a nontrivial example with seven language implemented (three of them are designed as DSLs) as the evidence for the power of Osazone (Section \ref{sec:eval}).
\end{itemize}
