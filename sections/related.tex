\section{Related Work}

Our work on language lifting for DSL is related to the work on meta-language design, DSL implementation and abstraction maintenance.

\paragraph{Abstraction Maintenance.}
For evaluation, the main related work is how to correspond the transformed program back to the source in optimization and debugging \cite{resugar,abs-1,abs-2,abs-3}.
Resugaring maintains abstraction dynamically and provides the evaluation sequences to users.
In order to illustrate the correctness of the evaluation sequences, resugaring proposes two properties: emulation and coverage \cite{resugar}.
We can only give the evaluation rules of the DSL now and 
 will consider giving the evaluation sequences holding these properties as future work.
% As far as we are aware, our framework is the first one to derive semantics for DSL and make it standalone.
For typing, \cite{infer-types,type-sound,type-sound-1} have done pretty much work on statically deriving typing rules and guaranteeing the soundness of type system for syntactic sugar.
The type derivation in our work is a natural application of the rule derivation
 and is not as competent as related work and is not our main contribution.

\paragraph{Meta-language Design.}
Our meta-language is designed built upon the skeletal semantics \cite{skeleton},
 which can capture the behaviour of a language construct in a single rule.
By providing different interpretation,
 the skeletal semantics can build consistency between abstract and concrete interpretations.
It has similars structure in behaviour description,
 but there are sharp differences from ours:
(1) We use two rules to describe evaluation and typing respectively, instead of a single rule in skeleton;
(2) Different from in skeleton, where a filter has various definition in different interpretation, 
 there is only one interpretation in our meta-language and the meta-functions are pre-defined.
(3) We permit the use of monad in computation to cover side effects.
K-framework \cite{K-framework}, Ott \cite{Ott} also allow users to define the semantics formally.
The semantics defined in K is rewrite-based, using matching logic.
For ease to use, K provides an executable interpreter and a program verifier.
Ott provides a meta-language to write semantics concisely and compiles these definition to Coq code.
The focus of these tools is on the formalization and verification of the language itself.
And our meta-language design concentrates on the feasibility of language lifting.

\paragraph{DSL Implementation.}
There is a long history of DSL implementation \cite{MartinDSL,when-how-dsl}.
Our translation rules are essentially similar to macros and syntactic sugar.
Distinguish from selecting the appropriate host language based on the DSL design,
 we put more emphasis on the gradual expansion of the host language to append required features \cite{MoggiMeta}.
The expression problem \cite{expr-problem} is orthogonal to our problem.
The goal of expression problem is the extensibility both in data structure and interpretations,
 keeping the existing modules intact.
Instead, we directly expand the existing data structure definition for translation rules,
 which is not allowed in the expression problem.
Our approach is on top of the host language and is neither deep or shallow embedding.
