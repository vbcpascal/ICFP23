\section{Meta-Language and Host Languages}\label{sec:host}

In this section, the syntax and semantics of our meta-language are formalized.
We will talk about the rules written by meta-language and their interpretation.
We will then briefly describe the importance of structural evaluation rules in host language,
 in preparation for the semantic derivation.
The concepts meta-language and host language (or any language defined by meta-language) need to be distinguished.

\subsection{Meta-Language}\label{sec:meta}

As mentioned above, our meta-language is inspired by Skeleton.
But it differs in the problems and is therefore adapted.
Skeleton focuses on illustrating the consistency of concrete and abstract interpretations.
The meaning of filters (meta-operations in Skeleton) varies in different goals.
We concentrate on evaluation and typing.
As an interpretation of Skeleton, it is intuitively close to Haskell.
For example, instead of branches, we use pattern matching;
 instead of defining the merging of the interpretation of branches,
 we will pick the first branch that successfully matches.
In addition, we support monad at the meta-language level.
We will show the syntax of the meta-language, 
 and how the meta-language is translated to Haskell to illustrate its semantics.

\subsubsection{Expressions of Meta-Language}
Various \textit{expressions} in the meta-language are used to encode the language constructs in the host language or the DSL, such as expressions and types.
(We use $L$ to refer to a language defined by meta-language like \STLC.
In the remainder of this section, we will indicate such language with an $L$ to distinguish from the meta-language.
Also, expressions $\mexp$ in meta-language need to be sperated from expressions in language $L$.)

An expression $\mexp$ is built by \textit{base expressions}, like literals and identifiers, ranged by $\mexp_b$;
 \textit{expression variables}, ranged by $\mexp_x$;
 and \textit{compound expressions} by \textit{constructors}, ranged by $c$.
Each language construct in $L$ corresponds to a constructor $c$ in meta-language.
To distinguish between various sorts of language constructs,
 we define $S$ for a finite set of \textit{sorts}, ranged over by $s$.
A sort $s$ can be either an \textit{base sort} like $\Int$, $\Id$;
 or a \textit{program sort} like $\Exp$, $\Type$ in \STLC.
The sort of an expression $\mexp$, written as $sort(\mexp)=s$,
 illustrate its role in language $L$.
A constructor $c$ has a signature $sig(c)$, which is of the form $(s_1\cdots s_n)->s$,
 where $s_1\cdots s_n$ are appropriate sorts of parameters of $c$,
 and $s$ is the sort of expressions constructed by $c$, briefly stated as sort of $c$.
A compound expression, written as $c(\mexp_1,\cdots,\mexp_n)$ or $c~\mexp_1\cdots\mexp_n$,
 is legal, if $sort(\mexp_i)=s_i$ for every $i\in [1,n]$.

\begin{example}
$λx\!:\<bool>.~e$ in language $L$, is constructor $\<Abs>$ applied to ``x'', $\<bool>$ and expression variable $e$.
 ``x'' are base expressions, and $sort(``x")=\Id$;
 $\<bool>$ is constructor $\<Bool>$ applied to nothing.
The signature of $\<Abs>$ is $sig(\<Abs>)=(\Id,\Type,\Exp)->\Exp$, and its sort is $\Exp$.
The signature and sort of $\<Bool>$ are both $\Type$.
\[
  \begin{array}{ccc}
    \text{Language } L & & \text{Meta-Language} \\
    λx\!:\<bool>.~e & \leftrightarrow & \<Abs>(``x",\<Bool>(),e) \text{ or } \<Abs>~``x"~\<Bool>~e
  \end{array}
\]

\end{example}

We use $i$ for expressions with sort $\Int$, $x$ for $\Id$, $e$ for $\Exp$, and $t$ for $\Type$.
A \textit{closed expression} $\cexp$ is an expression with no expression variables, generally refering to a concrete component in language $L$.
Let $Σ$ be an \textit{environment} mapping from expression variables to expressions. 
We write $Σ(\mexp)$ to replace all expression variables $\mexp_x\in dom(Σ)$ with $Σ(\mexp_x)$ in $\mexp$.
An environment $Σ$ is \textit{closed} for expression $\mexp$, when $Σ(\mexp)$ is a closed expression.

\subsubsection{Rules of Meta-Language}

\begin{figure}
  \begin{align*}
    b \in Bone 
      & ::= \mexp' & \text{(General Expression)} \\
      & \quad \mid h(\mexp') & \text{(Recursive Computation)} \\
      & \quad \mid f_m(\mexp'_1\cdots \mexp'_n) & \text{(Monadic Meta-function)} \\
      & \quad \mid b:(br_1\cdots br_n) & \text{(Pattern Matching)} \\
      & \quad \mid \Let{pat}{b_1} b_2 & \text{(Let Binding)} \\
    \mexp' \in \Exp_G
      & ::= \mexp & \text{(Expression)} \\
      & \quad \mid f_p(\mexp'_1\cdots \mexp'_n) & \text{(Pure Meta-function)} \\
    br \in Branch
      & ::= pat |> b \\
      & \quad \mid pat \mid \mexp' |> b \\
    pat \in \mathit{Pattern}
      & ::= \mexp_x & \text{(Pattern Variable)} \\
      & \quad \mid c~pat_1\cdots pat_n & \text{(Compound Pattern)}
  \end{align*}
\caption{Body of Rules in Meta-Language}
\label{fig:body}
\end{figure}

A rule of meta-language has the shape $h(c~\mexp_{x_1}\cdots \mexp_{x_n}) \cqq b$, 
 where $h$ is the name of interpretation like $\mathcal{E}$ and $\mathcal{T}$,
 $c$ is a constructor, 
 $\mexp_{x_1}\cdots \mexp_{x_n}$ are expression variables,
 and $d$ is the rule body.
An interpretation $h$ has a signature $sig(h)=s_1->m~s_2$, 
 where $s_1$ states for which $h$ computes,
 and $s_2$ states for the result of $h$,
 $m$ is the monad for side-effects.
When no side effects are introduced, $m$ can be omitted.
A body is composed of bones, shown in Fig. \ref{fig:body}.
A bone, which represents an operation, 
 can be either a general expression, 
 a recursive computation,
 or a meta-function.

General expressions are expressions $\mexp$ or computation of expressions with $f_p$.
Two types of meta-functions are mentioned here:
 monadic meta-functions, ranged over by $f_m$,
 pure meta-functions, ranged over by $f_p$.
% They are the same if computation is pure.
% But when monad is introduced, 
When monad is introduced,
 $f_m$ is function containing side effects, 
  whose signature is like $sig(f_m)=(s_1\cdots s_n)->m~s$;
 while $f_p$ is not,
  whose signature is of the form $sig(f_p)=(s_1\cdots s_n)->s$.
Most of these functions are pre-defined.
For example, $searchCtx$, $updateCtx$ and $restoreCtx$ are monadic meta-functions,
 equality checking $(=)$ and substitution are pure meta-functions.
The meta-functions represent primitive operations, and we assume that users can always understand their meaning.
Interestingly, in our meta-language, the use of monad in the body of rules is implicit,
 where $return$ or $bind$ need not be written explicitly.
An expression variable with sort $m~s$ is not allowed.
As a result, the method to tell if a binding is pure is by checking whether the bone is a general expression.

\subsubsection{Language $L$ Defined in Meta-Language}
A \textit{Language} $L$ consists of a set of program sorts $S_p$;
 a set of language constructs $C$ with signatures;
 a set of interpretations $H$ with rules;
 a set of meta-functions $F$, seprerated by monadic ones $F_m$ and pure ones $F_p$.

In particular, in \STLC and its extensions, $S_p=\{\Exp,\Type\}$.
$H$ can be seperated into a set of evaluation rules $R_{\mE}$ and a set of typing rules $R_{\mT}$,
 where $sig(\mE)=\Exp->m_1~\Exp$ and $sig(\mT)=\Exp->m_2~\Type$.
Substitution, as a pure meta-function, is divided from $F_p$ and described as a set of substitution rules $R_{subst}$,
 whose definition is defined by develops.
The signature of substitute is $sig(subst)=(\Exp,\Id,\Exp)->\Exp$.
In the latter, a language will be defined as follows:
\[ L=\langle S_p, C, R_{\mE}, R_{\mT}, R_{subst}, F_p, F_m \rangle \]

\subsubsection{Semantic of Meta-Language.}

In this section, we present the semantic of our meta-language.
We start by the pure computation.
Given a closed expression $\cexp$ in language $L$, for an interpretation $h$,
 whose sort is $s_1 -> s_2$, if $sort(\cexp)=s_1$, 
 then $h(\cexp)$ will be interpreted as a closed expression of sort $s_2$.
For example, an expression is interpreted as a value if $h$ is evaluation, written as $\cexp -> v$.
Here we use $v$ for the result of interpretation, which is a closed expression itself.
After monad is introduced, side effects can be embraced by labels in transformation \cite{msos}.
The operational semantics of meta-language are given in Fig. \ref{fig:seman-meta}.
\todo{Explain this in detail?}

\begin{figure}
  \begin{gather*}
    \inference[Base]{}{\mexp_b \lr \mexp_b} \\
    \inference[PureFun]{\mexp'_1 \lr v_1 ~\cdots~ \mexp'_n \lr v_n & v=f_p(v_1\cdots v_n)}{f_p(\mexp'_1\cdots \mexp'_n) \lr v} \\
    \inference[Rec]{\mexp' \lr v_1 & h(v_1) \rr{X} v}{h(\mexp) \rr{X} v} \\
    \inference[MonadicFun]{\mexp'_1 \lr v_1 ~\cdots~ \mexp'_n \lr v_n & f_m(v_1\cdots v_n) \rr{X} v}{f_m(\mexp'_1\cdots \mexp'_n) \rr{X} v} \\
    \inference[LetIn]{b_1 \rr{X_1} v_1 & Σ=\mathit{match}_p\ (v_1,pat) & Σ(b_2) \rr{X_2} v_2}{\Let{pat}{b_1} b_2 \rr{X_1;X_2} v_2} \\
    \inference[Branch]{b\rr{X_1} v & \text{FAIL}=\mathit{match}_{br}(v,br_i)_{i\in [1..k-1]} & 
      Σ=\mathit{match}_{br}(v,br_k) & Σ(body_{br}(br_k)) \rr{X_2} v_k}
      {b:(br_1\cdots br_n) \rr{X_1;X_2} v_k}
  \end{gather*}
  \caption{Semantics of Meta-Language}
  \label{fig:seman-meta}
\end{figure}

% \begin{figure}
%   \begin{gather*}
%     \inference[Var]{ρ(\mexp_x)=v}{\mexp_x \rr{\{ρ,...\}} v} \qquad
%     \inference[Base]{}{\mexp_b \lr \mexp_b} \\
%     \inference[PureFun]{\mexp'_1 \rr{\{ρ,...\}} v_1 ~\cdots~ \mexp'_n \rr{\{ρ,...\}} v_n & v=f_p(v_1\cdots v_n)}{f_p(\mexp'_1\cdots \mexp'_n) \rr{\{ρ,...\}} v} \\
%     \inference[Rec]{\mexp' \rr{\{ρ,...\}} v_1 & h(v_1) \rr{\{ρ,σ,σ'\}} v}{h(\mexp) \rr{\{ρ,σ,σ'\}} v} \\
%     \inference[MonadicFun]{\mexp'_1 \rr{\{ρ,...\}} v_1 ~\cdots~ \mexp'_n \rr{\{ρ,...\}} v_n & f_m(v_1\cdots v_n) \rr{\{ρ,σ,σ'\}} v}{f_m(\mexp'_1\cdots \mexp'_n) \rr{\{ρ,σ,σ'\}} v} \\
%     \inference[LetIn]{b_1 \rr{\{ρ,σ,σ'\}} v_1 & pat\mapsto v_1\ne\emptyset & b_2 \rr{\{ρ[pat\mapsto v_1],σ',σ''\}} v_2}{\Let{pat}{b_1} b_2 \rr{\{ρ,σ,σ''\}} v_2} \\
%     \inference[Branch]{b\rr{\{ρ,σ,σ'\}} v & \mathit{match\mhyphen fail}\ (v,br_i)_{i\in [1..k-1]} & \mathit{match}\ (v,br_k) \\ 
%       br_k=pat|>b_k & b_k \rr{\{ρ[pat\mapsto v],σ',σ''\}} v_k}
%       {b:(br_1\cdots br_n) \rr{\{ρ,σ,σ''\}} v_k}
%   \end{gather*}
%   \caption{Semantics of Meta-Language}
%   \label{fig:seman-meta}
% \end{figure}


\subsection{Host Languages}\label{sec:m-host}

Remember that our host language is designed to define DSL.
In semantic derivation, the rules can be expanded recursively,
 because the original rules contain the evaluation or typing of subexpressions.
Therefore, the rules of the language constructs of the host language should be \textit{structural}:
 the evaluation of an expression $e=c(e_i,...)$ with sort $\Exp$ should be a computation of the value of each subexpression $e_i$ where $sort(e_i)=\Exp$.
If some subexpression $e_i$ is used without evaluation, 
 or some expression being evaluated is not $e_i$,
 then the rule is not structural.In the case of \STLC, the evaluation rules of $\<if>$ and $\<and>$ are structural.
And the evaluation rules of lambda abstraction and application are not structural.
The former uses the $e_i$ not evaluated, while the latter evaluates an expression containing substitution.
We rewrite these rules in the style of meta-language, where unstructural parts are highlighted:
% weak alert
\newcommand{\wkalt}[1]{\colorbox{lightgray}{#1}}
\begin{align*}
  \EE{\<Abs>~x~t~e} & \cqq \<Abs>~x~t~\wkalt{$e$} \\
  \EE{\<App>~e_1~e_2} & \cqq \Let{\<Abs>~x~t~e}{\EE{e_1}} \Let{v_2}{\EE{e_2}} \wkalt{$\EE{subst~e~x~v_2}$}.
\end{align*}

\begin{definition}
A rule $h(c~\mexp_{x_1}\cdots \mexp_{x_n})=b$ is structural, if
\begin{itemize}
  \item for each $\mexp_{x_i}$ satisfying $sort(\mexp_{x_i})=sort(c)$, 
   $\mexp_{x_i}$ is not used to be matched, as an argument in any meta-function, applied by any constructor, or as the result value in $b$;
  \item all the expressions that are computed recursively $h(\mexp)$ in $b$ must be $\mexp_{x_i}$.
\end{itemize}
\end{definition}

Structural evaluation rules are the key to ensure the abstraction in semantic derivation.
In other words, any language construct with unstructural evaluation rule needs to be carefully accounted for in terms of how it will affect the semantic derivation.
The typing rules, fortunately, are all structural in \STLC.
