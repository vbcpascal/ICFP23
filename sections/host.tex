\section{Meta-Language and Host Languages}\label{sec:host}

In this section, we formalize the syntax and semantics of our meta-language (Section \ref{sec:meta}).
The meta-language is used to define the semantics and typing rules of languages.
We define \STLC{} with this meta-language as an instance.
Then we want to emphasize the importance of structural evaluation rules of host language,
 in preparation for the semantics derivation (Section \ref{sec:m-host}).
Note the difference between concepts of meta-language and host languages (or any language defined by meta-language) in this section.
We use $L$ to refer to a language defined by meta-language like \STLC.
In the remainder of this section, we will indicate such language with an $L$ to distinguish from the meta-language.

\subsection{Meta-Language}\label{sec:meta}

Our meta-language is inspired by Skeleton \cite{skeleton}, 
 used to describe concrete and abstract semantics in a structural way.
A skeleton body is defined by a sequence of bones.
A bone is either recursive computations (hooks), filters, or branches.
Skeleton focuses on illustrating the consistency of concrete and abstract interpretations.
The meaning of filters varies in different goals.
But our meta-language concentrate on evaluation and typing,
 whose design is intuitively close to Haskell.
In particular, we replace branches and merging operation with pattern matching,
 and replace filters with meta-functions.
In addition, monad is supported to cover side effects in meta-language. % at the meta-language level.

\todo{Overview of this subsection: language, rule, expression}
\[   \EE{e_1~\<and>~e_2} \cqq \EE{e_1}: \branch{
    \<true>  |> \EE{e_2} \\&
    \<false> |> \<false> } \]

\subsubsection{Expressions of Meta-Language}
Various \textit{expressions} in the meta-language are used to encode the language constructs in the host language or the DSL, such as expressions and types.

An expression $\mexp$ is built by \textit{base expressions}, like literals and identifiers, ranged over by $\mexp_b$;
 \textit{expression variables}, ranged over by $\mexp_x$;
 and \textit{compound expressions} by \textit{constructors}, ranged over by $c$.
Each language construct in $L$ corresponds to a constructor $c$ in meta-language.
To distinguish between various sorts of language constructs,
 we define $S$ for a finite set of \textit{sorts}, ranged over by $s$.
A sort $s$ can be either an \textit{base sort} like $\Int$, $\Id$;
 or a \textit{program sort} like $\Exp$, $\Type$ in \STLC.
The sort of an expression $\mexp$, written as $sort(\mexp)=s$,
 illustrates its role in language $L$.
A constructor $c$ has a signature $sig(c)$, which is of the form $(s_1\cdots s_n)->s$,
 where $s_1\cdots s_n$ are appropriate sorts of parameters of $c$,
 and $s$ is the sort of expressions constructed by $c$, briefly stated as sort of $c$.
A compound expression, written as $c(\mexp_1,\cdots,\mexp_n)$ or $c~\mexp_1\cdots\mexp_n$,
 is valid, if $sort(\mexp_i)=s_i$ for each $i\in [1..n]$.

\begin{example}
Expression $λx\!\!:\!\!\<bool>.~e$ in language $L$, is constructor $\<Abs>$ applied to ``x'', $\<bool>$ and expression variable $e$.
 ``x'' is a base expression, and $sort(``x")=\Id$;
 $\<bool>$ is constructor $\<Bool>$ applied to nothing.
The signature of $\<Abs>$ is $sig(\<Abs>)=(\Id,\Type,\Exp)->\Exp$, and its sort is $\Exp$.
The signature of $\<Bool>$ is $()->\Type$, and its sort is $\Type$.
\[
  \begin{array}{ccc}
    % \text{Language } L & & \text{Meta-Language} \\
    λx\!:\<bool>.~e & \leftrightarrow & \<Abs>(``x",\<Bool>(),e) \text{ or } \<Abs>~``x"~\<Bool>~e
  \end{array}
\]
\end{example}

We use $i$ for expressions with sort $\Int$, $x$ for $\Id$, $e$ for $\Exp$, and $t$ for $\Type$.
A \textit{closed expression} $\cexp$ is an expression with no expression variables, generally refering to a concrete component in language $L$.
Let $Σ$ be an \textit{environment} mapping from expression variables to expressions. 
We write $Σ(\mexp)$ to replace all expression variables $\mexp_x\in dom(Σ)$ with $Σ(\mexp_x)$ in $\mexp$.
An environment $Σ$ is \textit{closed} for expression $\mexp$, when $Σ(\mexp)$ is a closed expression.

\subsubsection{Rules of Meta-Language}

\begin{figure}
  \begin{align*}
    b \in Bone 
      & ::= \mexp' & \text{(Pure Expression)} \\
      & \quad \mid h(\mexp') & \text{(Recursive Computation)} \\
      & \quad \mid f_m(\mexp'_1\cdots \mexp'_n) & \text{(Monadic Meta-function)} \\
      & \quad \mid b:(br_1\cdots br_n) & \text{(Pattern Matching)} \\
      & \quad \mid \Let{pat}{b_1} b_2 & \text{(Let Binding)} \\
    \mexp' \in \Exp_P
      & ::= \mexp & \text{(Expression)} \\
      & \quad \mid f_p(\mexp'_1\cdots \mexp'_n) & \text{(Pure Meta-function)} \\
    br \in Branch
      & ::= pat |> b \\
      & \quad \mid pat \mid \mexp' |> b \\
    pat \in \mathit{Pattern}
      & ::= \mexp_x & \text{(Pattern Variable)} \\
      & \quad \mid c~pat_1\cdots pat_n & \text{(Compound Pattern)}
  \end{align*}
\caption{Body of Rules in Meta-Language}
\label{fig:body}
\end{figure}

A rule of meta-language has the shape $h(c~\mexp_{x_1}\cdots \mexp_{x_n}) \cqq b$, 
 where $h$ is the name of interpretation like $\mathcal{E}$ and $\mathcal{T}$,
 $c$ is a constructor, 
 $\mexp_{x_1}\cdots \mexp_{x_n}$ are expression variables,
 and $b$ is the rule body.
An interpretation $h$ has a signature of the form $s_1->m~s_2$, 
 written as $sig(h)=s_1->m~s_2$ or $h:s_1->m~s_2$, 
 where $s_1$ states for which $h$ computes,
 and $s_2$ states for the result of $h$,
 $m$ is the monad for side-effects.
When no side effects are introduced, $m$ can be omitted.
The rule body is composed of bones, shown in Fig. \ref{fig:body}.
A bone, which represents a step of operation, 
 can be either a pure expression,
 a recursive computation,
 or a meta-function.

\begin{example}
  The typing rule of $\<if>$ is defined as follows:
  \[
    \TT{\<if>~e_1~e_2~e_3} \cqq
      \lt~\<bool> = \TT{e_1};~
      \lt~t_2 = \TT{e_2};~
    \TT{e_3}:(t_3 \mid t_2 = t_3 |> t_2)
  \]
  We use $let$ as a syntactic sugar to represent a pattern matching with only one branch.
  In this rule, the type of $e_1$ is required to be $\<bool>$.
  The matching of $\TT{e_3}$ has a side condition (named \textit{guard} in Haskell),
  which requires $t_2=t_3$.
\end{example}

Pure expressions are expressions $\mexp$ or computation results of pure meta-function $f_p$.
The meta-functions represent primitive operations, and we assume that users can always understand their meaning, like equality checking $(=)$.
Most of these functions are pre-defined.
Two types of meta-functions are mentioned here:
 monadic meta-functions, ranged over by $f_m$,
 pure meta-functions, ranged over by $f_p$.
They are the same if the interpretation is pure.
When monad is introduced,
 $f_m$ is function containing side effects, 
  whose signature is like $sig(f_m)=(s_1\cdots s_n)->m~s$;
 while $f_p$ is not,
  whose signature is like $sig(f_p)=(s_1\cdots s_n)->s$.
% For example, $searchCtx$, $updateCtx$ and $restoreCtx$ are monadic meta-functions,
%  equality checking $(=)$ and substitution are pure meta-functions.

A \textit{closed bone} $\cb$ is a bone without any free expression variables,
 which can be reduced to an expression.
Also, we extend the environment to bone as $Σ(b)$, which replaces free expression variables in $dom(Σ)$.

In our meta-language, $\mathit{return}$ or $\mathit{bind}$ in the body of rules are used implicit.
An expression variable bound with sort $m~s$ is not allowed.
As a result, the method to tell whether a binding is pure is by checking if the bone is a pure expression.
\todo{not clear?}

\subsubsection{Language $L$ Defined in Meta-Language}
A \textit{Language} $L$ consists of a set of program sorts $S_p$;
 a set of language constructs $C$ with signatures;
 a set of interpretations $H$ with rules;
 a set of meta-functions $F$, devided into monadic ones $F_m$ and pure ones $F_p$.

In particular, in \STLC{}, $S_p=\{\Exp,\Type\}$.
$H$ can be seperated into a set of evaluation rules $R_{\mE}$ and a set of typing rules $R_{\mT}$.
The evaluation rules of \STLC{} are defined in Fig. \ref{fig:stlc} where $\mE:\Exp->\Exp$.
But when typing \STLC, a context (or environment) mapping variables to types is necessary.
Instead of making the signature $\mT$ be $\Exp -> Ctx -> \Type$,
 we introduce state monad to describe context modification\footnote{
  A more direct approach is to use the reader monad and change the environment locally via $\mathit{local}$.
  But $\mathit{local}$ needs a monadic computation as argument, which is not allowed.
 },
 with monadic meta-functions $searchCtx$, $updateCtx$ and $restoreCtx$.
When typing lambda abstractions $λx:t.e$, the type of variable $x$ should be updated into context first with $updateCtx$.
After typing the body of lambda abstractions $e$, restore the type of variable $x$ in the context.
In the concrete implementation, the stack of the context is used as the state.
When searching for the type of a variable, the context at the topmost level is looked up.
Updating the context will push the new context onto the stack and restoring will pop one.
So the signature of $\mT$ is modified to $\Exp -> (State~\mathit{CtxStack})~\Type$.
And the typing rules are defined in Fig. \ref{fig:stlc_type}.

\begin{figure}[t!]
  \begin{align*}
    \EE{\<true>}           & \cqq \<true> \\
    \EE{\<false>}          & \cqq \<false> \\
    \EE{\<if>~e_1~e_2~e_3} & \cqq \EE{e_1}: \branch{
      \<true>  |> \EE{e_2} \\&
      \<false> |> \EE{e_3}
    } \\
    \EE{λx:t.e}            & \cqq λx:t.e \\
    \EE{e_1~e_2}           & \cqq \lt~λx:t.e=\EE{e_1};~\lt~v_2=\EE{e_2};~\EE{e[v_2/x]}
  \end{align*}
  \caption{Evaluation Rules of \STLC}
  \label{fig:stlc}
\end{figure}

\begin{figure}[t!]
  \begin{align*}
    \TT{\<true>}  & \cqq \<bool>  \\
    \TT{\<false>} & \cqq \<bool>  \\
    \TT{\<if>~e_1~e_2~e_3} & \cqq
      \lt~\<bool> = \TT{e_1};~
      \lt~t_2 = \TT{e_2};~
      \TT{e_3}:(t_3 \mid t_2 = t_3 |> t_2)   \\
    \TT{x}        & \cqq searchCtx~x \\
    \TT{λx:t.e}   & \cqq \lt~\_=updateCtx~x~t;~\lt~t'=\TT{e}; \\
                  & \hspace{13pt} \lt~\_=restoreCtx;~t->t' \\
    \TT{e_1~e_2}  & \cqq \Let{t_1->t}{\TT{e_1}} \TT{e_2}:(t_2\mid t_1=t_2|>t)
  \end{align*}
  \caption{Typing Rules of \STLC}
  \label{fig:stlc_type}
\end{figure}

Substitution, as a pure meta-function, is divided from $F_p$ and described as a set of substitution rules $R_{subst}$.
The signature of substitute is $sig(subst)=(\Exp,\Id,\Exp)->\Exp$.
The substitution rules of language constructs should be specified by developers, omitted here.

In the rest of this paper, a language (\STLC{} or its extensions) are presented as follows:
\[ L=\langle S_p, C, R_{\mE}, R_{\mT}, R_{subst}, F_p, F_m \rangle \]

\begin{requirement}
  For any constructor $c$ with sort $\Exp$, the evaluation rule, the typing rule and the substitution rule in $L$ should be unique.
  % (Variable has no evaluation rules.)
\end{requirement}

When a closed expression $\cexp$ is evaluated (or typed) in $L$,
 we need to find a rule in $L$ and apply it to $\cexp$.
We write $L[\cexp]_{\mE}=Σ(b)$, if there exists a rule $\mE(c~\mexp_{x_1}\cdots \mexp_{x_n}) \cqq b$ in $R_{\mE}$ and an environment $Σ$,
 so that $\cexp=Σ(c~\mexp_{x_1}\cdots \mexp_{x_n})$.

\subsubsection{Semantics of Meta-Language}

In this section, we present the semantics of our meta-language.
We start by the pure computation.
Given a closed expression $\cexp$ in language $L$, for an interpretation $h$,
 whose sort is $s_1 -> s_2$, if $sort(\cexp)=s_1$, 
 then $h(\cexp)$ will be computed to get a closed expression of sort $s_2$.
% For example, an expression is interpreted as a value if $h$ is evaluation, written as $\cexp -> v$.
% Here we use $v$ for the result of interpretation, which is a closed expression itself.
After monad is introduced, side effects can be embraced by labels in transformation \cite{msos}.
The operational semantics of meta-language are given in Fig. \ref{fig:seman-meta}.
\todo{Explain this in detail?}

\begin{figure}
  \begin{gather*}
    \inference[Base]{}{\mexp_b \lr \mexp_b} \\
    \inference[PureFun]{\mexp'_1 \lr v_1 ~\cdots~ \mexp'_n \lr v_n & v=f_p(v_1\cdots v_n)}{f_p(\mexp'_1\cdots \mexp'_n) \lr v} \\
    \inference[Rec]{\mexp' \lr v_1 & L[v_1]_h \rr{X} v}{h(\mexp) \rr{X} v} \\
    \inference[MonadicFun]{\mexp'_1 \lr v_1 ~\cdots~ \mexp'_n \lr v_n & f_m(v_1\cdots v_n) \rr{X} v}{f_m(\mexp'_1\cdots \mexp'_n) \rr{X} v} \\
    \inference[LetIn]{b_1 \rr{X_1} v_1 & Σ=\mathit{match}_p\ (v_1,pat) & Σ(b_2) \rr{X_2} v_2}{\Let{pat}{b_1} b_2 \rr{X_1;X_2} v_2} \\
    \inference[Branch]{b\rr{X_1} v & \text{FAIL}=\mathit{match}_{br}(v,br_i)_{i\in [1..k-1]} & 
      Σ=\mathit{match}_{br}(v,br_k) & Σ(body_{br}(br_k)) \rr{X_2} v_k}
      {b:(br_1\cdots br_n) \rr{X_1;X_2} v_k}
  \end{gather*}
  \caption{Semantics of Meta-Language}
  \label{fig:seman-meta}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Host Languages with Structural Semantics}\label{sec:m-host}

Remember that our host language is designed to define DSL.
In semantics lifting, the rules should be expanded recursively.
%  because the original rules contain the evaluation of subexpressions.

Therefore, the rules of the language constructs of the host language should be \textit{structural}:
 the evaluation of an expression $e=c(e_i,...)$ with sort $\Exp$ should be a computation of the value of each subexpression $e_i$ where $sort(e_i)=\Exp$.
If some subexpression $e_i$ is used without evaluation, 
 or some expression being evaluated is not $e_i$,
 then the rule is not structural.In the case of \STLC, the evaluation rules of $\<if>$ and $\<and>$ are structural.
And the evaluation rules of lambda abstraction and application are not structural.
The former uses the $e_i$ not evaluated, while the latter evaluates an expression containing substitution.
We rewrite these rules in the style of meta-language, where unstructural parts are highlighted:
% weak alert
% \newcommand{\wkalt}[1]{\colorbox{lightgray}{#1}}
\newcommand{\wkalt}[1]{\textcolor{magenta}{#1}}
\begin{align*}
  \EE{\<Abs>~x~t~e} & \cqq \<Abs>~x~t~\wkalt{e} \\
  \EE{\<App>~e_1~e_2} & \cqq \Let{\<Abs>~x~t~e}{\EE{e_1}} \Let{v_2}{\EE{e_2}} \wkalt{\EE{subst~e~x~v_2}}.
\end{align*}

\begin{definition}
A rule $h(c~\mexp_{x_1}\cdots \mexp_{x_n})=b$ is structural, if
\begin{itemize}
  \item for each $\mexp_{x_i}$ satisfying $sort(\mexp_{x_i})=sort(c)$, 
   $\mexp_{x_i}$ is not used to be matched, as an argument in any meta-function, applied by any constructor, or as the result value in $b$;
  \item all the expressions that are computed recursively $h(\mexp)$ in $b$ must be $\mexp_{x_i}$.
\end{itemize}
\end{definition}

Structural evaluation rules are the key to ensure the abstraction in semantic derivation.
In other words, any language construct with unstructural evaluation rule needs to be carefully accounted for in terms of how it will affect the semantic derivation.
The typing rules, fortunately, are all structural in \STLC.
