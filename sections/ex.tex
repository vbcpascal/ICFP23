\section{Host Language Extension}\label{sec:ex}

We discuss how to extend the host language when it is not expressive enough.
The extensions can be seperated into two types:
 meta-extensions and monadic extensions.
The former adds new vocabularies to the host language,
 for example adding integers to \STLC.
Meta-language extensions are similar to defining a host language.
The latter is adding new features to the meta-language by monad like reference.
The original language definitions can be kept intact when introducing new language features.


\subsection{Meta-Extensions}

Meta-extensions are direct extensions to the host language by
 adding new constructors $C_n$ with corresponding rules, and new meta-functions $F_n$.
This expansion has the following requirements: for each $c \in C_n$,
 (1) $sort(c) \in S_p$, i.e. $\Exp$ or $\Type$;
 (2) if $sort(c)=\Exp$, then the evaluation, typing and substitution rules should be specified.

\begin{example}
  Consider integers are expected to be supported via literals.
  New constructors, $\<Lit>$, $\<Plus>$, $\<Lt>$ and $\<Eq>$ as $\Exp$, $\<Int>$ as $\Type$, will be added.
  Fig. \ref{fig:int} shows the formal definition of integer extension, 
  where $F_n=\{(=),(+),(<)\}$, all of them are pure meta-functions.
\end{example}

\begin{figure}
  \begin{align*}
    & \<Int>:\Type \\ 
    & \<Lit>:\Int->\Exp & 
    & \EE{\<Lit>~i} \cqq \<Lit>~i \hspace{5em} \TT{\<Lit>~i} \cqq \<Int> \\
    & & & (\<Lit>~i)[e/x] = \<Lit>~i \\
    & \<Plus>:(\Exp,\Exp)->\Exp &
    & \EE{\<Plus>~e_1~e_2} \cqq \Let{\<Lit>~i_1}{\EE{e_1}} \Let{\<Lit>~i_2}{\EE{e_2}} \<Lit>~(i_1+i_2) \\
    & & & \TT{\<Plus>~e_1~e_2} \cqq \Let{\<Int>}{\TT{e_1}} \Let{\<Int>}{\TT{e_2}} \<Int> \\
    & & & (\<Plus>~e_1~e_2)[e/x]=\<Plus>~e_1[e/x]~e_2[e/x] \\
    & \<Lt>:(\Exp,\Exp)->\Exp &
    & \EE{\<Lt>~e_1~e_2} \cqq \Let{\<Lit>~i_1}{\EE{e_1}} \EE{e_2}:\branch{
        \<Lit>~i_2 \mid i_1 < i_2 |> \<True> \\&
        \<Lit>~\_ |> \<False> 
      } \\
    & & & \TT{\<Lt>~e_1~e_2} \cqq \Let{\<Int>}{\TT{e_1}} \Let{\<Int>}{\TT{e_2}} \<Bool> \\
    & & & (\<Lt>~e_1~e_2)[e/x]=\<Lt>~e_1[e/x]~e_2[e/x] \\
    & \<Eq>:(\Exp,\Exp)->\Exp &
    & \EE{\<Eq>~e_1~e_2} \cqq \Let{\<Lit>~i_1}{\EE{e_1}} \EE{e_2}:\branch{
        \<Lit>~i_2 \mid i_1 = i_2 |> \<True> \\&
        \<Lit>~\_ |> \<False> 
      } \\
    & & & \TT{\<Eq>~e_1~e_2} \cqq \Let{\<Int>}{\TT{e_1}} \Let{\<Int>}{\TT{e_2}} \<Bool> \\
    & & & (\<Eq>~e_1~e_2)[e/x]=\<Eq>~e_1[e/x]~e_2[e/x] \\
  \end{align*}
  \caption{Formal Definition of Integer Extension}
  \label{fig:int}
\end{figure}

\subsection{Monad Extensions}\label{sec:dsl-monad}

Monad extension \cite{monad-1,monad-2} is the technique for side effects in computation without changing the original semantic definition.
By monad $m$, various language features can be defined, such as environment, store, nondeterminism, I/O etc.
In order to put these together in a modular way, we use a mechanism called \textit{monad transformers} \cite{monad-tr}, ranged over by $m_t$.
In this section, we will introduce reference to \STLC, named \textsc{Ref}.
Both the change of pure computation to those including side effects via monad (in evaluation),
 and the composition of language features via monad transformer (in typing) will be explained.
Then, we aim to make \textsc{Ref} support I/O named \RefIO.
Unlike other monads, IO monad cannot be used as a monad transformer,
 which can be the base monad only.
We will explain our strategies in the language \RefIO.

\subsubsection{Evaluation with Store}

Monad extensions are often accompanied by meta-extensions.
The basic language constructs of reference are allocation $ref~e$, dereferencing $!e$ and assignment $e_1:=e_2$.
To carry through the modification on store, 
 the signature of $\mathcal{E}$ changes from $\Exp->\Exp$,
 to $\Exp->(\mathit{State~Store})~\Exp$, abbreviated as $M_e~\Exp$,
 where $\mathit{Store}$ maps locations to values.
% In our meta-language, it is written as:
\[ \mathcal{E} : \Exp -> \wkalt{\mathit{State~Store}}~\Exp \]
% \[ \mathcal{E} : \Exp -> \Exp ~\wkalt{\monad \mathit{State~Store} \as M_e} \]

An abstract index of store is a location (used as a base sort $Loc$).
An allocation will be evaluated to a location expression.
A location in \textsc{Ref} is written as $l$ directly, constructed by $\<Loc>$ whose sort is $Loc->\Exp$.
New (monadic) meta-functions are also necessary for evaluation rules:
\begin{itemize}
  \item $\newLoc:M_e~Loc$ returns a newly allocated location;
  \item $\store:(Loc,\Exp)->M_e~()$ updates the store to make the location contain the value;
  \item $\fetch:Loc->M_e~\Exp$ gets the value at the location from the store.
\end{itemize}
Given these meta-functions, Fig. \ref{fig:ref_eval} shows the evaluation rules of these newly defined language constructs.

\begin{figure}
  \begin{align*}
    \EE{\<Loc>~loc} & \cqq \<Loc>~loc \\
    \EE{ref~e} & \cqq \Let{v}{\EE{e}} \Let{loc}{\newLoc} \Let{()}{\store~(loc,v)} \<Loc>~loc \\
    \EE{!e} & \cqq \Let{\<Loc>~loc}{\EE{e}} \fetch~loc \\
    \EE{e_1:=e_2} & \cqq \Let{\<Loc>~loc}{\EE{e}} \Let{v_2}{\EE{e_2}} \Let{()}{\store~(loc,v)} ()
  \end{align*}
  \caption{Evaluation Rules of \textsc{Ref}}
  \label{fig:ref_eval}
\end{figure}

When introducing monad, pure meta-functions keep the original definition, 
 while monadic meta-functions $f_m:(s_1\cdots s_n)->s$ need to lift to $\lifted{f_m}:(s_1\cdots s_n)->m~s$ for type correctness, defined by:
\[ \lifted{f_m}(\mexp_1\cdots \mexp_n) = \return~(f_m(\mexp_1\cdots \mexp_n)). \]

\subsubsection{Typing with Store}
If the content of a location has type $t$, then the type of the location is $Ref~t$,
 introducing new constructor $\<Ref>$, whose sort is $sort(\<Ref>)=\Type->\Type$.
Also unit type is essential.
To extend the store typing which records the association between location and their types,
 the signature of $\mathcal{T}$ changes from $\Exp->State~CtxStack~\Type$,
 to $\Exp->\mathit{ReaderT}~Store_t~(State~CtxStack)~\Type$,
 where $Store_t$ maps locations to types,
 and $ReaderT~Store_t$ is a monad transformer.
\[ \mathcal{T} : \Exp -> \wkalt{\mathit{ReaderT~Store}_t}~(\mathit{State~CtxStack})~\Type \]

% In our meta-language, we add the newly introduced monad on the right of the declaration
%  and do not need to explicitly state this monad is used as a monad transformer. 
% We restrict the monad used by the user to be pre-provided by our framework.

Monad transformers allow us touch high-level language features, but skill keep the access to low-level details.
Now, for example, we can use both the meta-functions associated with store typing like $ask$ and the meta-functions provided by Context like $searchCtx$.
Fig. \ref{fig:ref_type} gives the typing rules of language constructs in \textsc{Ref}.

\begin{figure}
  \begin{align*}
    \TT{\<Loc>~loc} & \cqq \Let{t}{ask~loc} Ref~t \\
    \TT{ref~e} & \cqq \Let{t}{\TT{e}} Ref~t \\
    \TT{!e} & \cqq \Let{Ref~t}{\TT{e}} t \\
    \TT{e_1:=e_2} & \cqq \Let{Ref~t}{\TT{e_1}} \TT{e_2}:(t_2 \mid t = t_2 |> Unit)
  \end{align*}
  \caption{Typing Rules of \textsc{Ref}}
  \label{fig:ref_type}
\end{figure} 

Likewise, pure meta-functions remains unchanged,
 and all the monadic meta-functions $f_m:(s_1\cdots s_n)->m~s$ need to lift to $\lifted{f_m}:(s_1\cdots s_n)->(m_t~m)~s$ by $\mathit{lift}$ operation.
For example, the typing rule of lambda abstraction in \textsc{Ref} will be written as:
\begin{align*}
  \TT{Î»x:t.e}   & \cqq \lt~\_=\lifted{updateCtx}~x~t;~\lt~t'=\TT{e}; \\
                & \hspace{13pt} \lt~\_=\lifted{restoreCtx};~t->t'.
\end{align*}

\subsubsection{IO Monad}

As mentioned, due to the absence of IO monad transformer, we cannot support I/O as the above approach.
For this, we always put an identity monad or IO monad at bottom, with other monads layered on top.
When I/O is required, replace identity monad with IO monad.
Then lift I/O functions, with other monadic meta-functions unchanged.

For example, in \STLC, the signature of evaluation is expressed as $\mE: \Exp -> \Exp$.
And now the signature is changed to $\mE: \Exp -> \mathit{Identity}~\Exp$.
% An additional benefit of this is that when introducing a new monad,
%  we do not need to distinguish whether it is a base monad or not,
%  so that all the monadic meta-functions are lifted by the $\mathit{lift}$ operator directly.
Then, the signature of evaluation in \textsc{Ref} is transformed into:
\[ \mathcal{E} : \Exp -> \mathit{StateT~Store~Identity}~\Exp \]
To support I/O, the signature of evaluation in \RefIO{} becomes:
\[ \mathcal{E} : \Exp -> \mathit{StateT~Store~IO}~\Exp. \]
And meta-functions provided by IO monad are lifted once:
\[ \lifted{\<print>}~e = \mathit{lift}~(\<print>~e). \]
