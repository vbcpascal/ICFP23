@article{LOP,
  title   = {Language-Oriented Programming},
  author  = {Martin P. Ward},
  journal = {Softw. Concepts Tools},
  year    = {1994},
  volume  = {15},
  pages   = {147-161}
}

@inproceedings{resugar,
  author    = {Pombrio, Justin and Krishnamurthi, Shriram},
  title     = {Resugaring: Lifting Evaluation Sequences through Syntactic Sugar},
  year      = {2014},
  isbn      = {9781450327848},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2594291.2594319},
  doi       = {10.1145/2594291.2594319},
  abstract  = {Syntactic sugar is pervasive in language technology. It is used to shrink the size of a core language; to define domain-specific languages; and even to let programmers extend their language. Unfortunately, syntactic sugar is eliminated by transformation, so the resulting programs become unfamiliar to authors. Thus, it comes at a price: it obscures the relationship between the user's source program and the program being evaluated.We address this problem by showing how to compute reduction steps in terms of the surface syntax. Each step in the surface language emulates one or more steps in the core language. The computed steps hide the transformation, thus maintaining the abstraction provided by the surface language. We make these statements about emulation and abstraction precise, prove that they hold in our formalism, and verify part of the system in Coq. We have implemented this work and applied it to three very different languages.},
  booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {361–371},
  numpages  = {11},
  keywords  = {programming languages, evaluation, syntactic sugar, macros, resugaring, debugging},
  location  = {Edinburgh, United Kingdom},
  series    = {PLDI '14}
}

@inproceedings{lazy-desg,
  author    = {Yang, Ziyi and Xiao, Yushuo and Guan, Zhichao and Hu, Zhenjiang},
  title     = {A Lazy Desugaring System for Evaluating Programs With Sugars},
  year      = {2022},
  isbn      = {978-3-030-99460-0},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  url       = {https://doi.org/10.1007/978-3-030-99461-7_14},
  doi       = {10.1007/978-3-030-99461-7_14},
  abstract  = {Extending a programming language with syntactic sugars is common practice in language design. Given a core language, one can define a surface language on top of it with sugars. We propose a lazy desugaring system, which can generate the evaluation sequences of sugar programs in the syntax of the surface language. Specifically, we define an evaluation strategy on a mixed language which combines syntactic sugars with the core language. We formulate two properties, emulation and laziness, and prove that the evaluation strategy produces correct evaluation sequences. Besides, we have implemented a system based on this novel method and demonstrate its usefulness with several examples.},
  booktitle = {Functional and Logic Programming: 16th International Symposium, FLOPS 2022, Kyoto, Japan, May 10–12, 2022, Proceedings},
  pages     = {243–261},
  numpages  = {19},
  location  = {Kyoto, Japan}
}

@article{infer-types,
  author     = {Pombrio, Justin and Krishnamurthi, Shriram},
  title      = {Inferring Type Rules for Syntactic Sugar},
  year       = {2018},
  issue_date = {April 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {53},
  number     = {4},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/3296979.3192398},
  doi        = {10.1145/3296979.3192398},
  abstract   = {Type systems and syntactic sugar are both valuable to programmers, but sometimes at odds. While sugar is a valuable mechanism for implementing realistic languages, the expansion process obscures program source structure. As a result, type errors can reference terms the programmers did not write (and even constructs they do not know), baffling them. The language developer must also manually construct type rules for the sugars, to give a typed account of the surface language. We address these problems by presenting a process for automatically reconstructing type rules for the surface language using rules for the core. We have implemented this theory, and show several interesting case studies.},
  journal    = {SIGPLAN Not.},
  month      = {jun},
  pages      = {812–825},
  numpages   = {14},
  keywords   = {Macros, Syntactic Sugar, Type Systems, Programming Languages, Resugaring}
}

@article{skeleton,
  author     = {Bodin, Martin and Gardner, Philippa and Jensen, Thomas and Schmitt, Alan},
  title      = {Skeletal Semantics and Their Interpretations},
  year       = {2019},
  issue_date = {January 2019},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {3},
  number     = {POPL},
  url        = {https://doi.org/10.1145/3290357},
  doi        = {10.1145/3290357},
  abstract   = {The development of mechanised language specification based on structured operational semantics, with applications to verified compilers and sound program analysis, requires huge effort. General theory and frameworks have been proposed to help with this effort. However, none of this work provides a systematic way of developing concrete and abstract semantics, connected together by a general consistency result. We introduce a skeletal semantics of a language, where each skeleton describes the complete semantic behaviour of a language construct. We define a general notion of interpretation, which provides a systematic and language-independent way of deriving semantic judgements from the skeletal semantics. We explore four generic interpretations: a simple well-formedness interpretation; a concrete interpretation; an abstract interpretation; and a constraint generator for flow-sensitive analysis. We prove general consistency results between interpretations, depending only on simple language-dependent lemmas. We illustrate our ideas using a simple While language.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {jan},
  articleno  = {44},
  numpages   = {31},
  keywords   = {programming language, semantics, abstract interpretation}
}

@inproceedings{hygine,
author = {Kohlbecker, Eugene and Friedman, Daniel P. and Felleisen, Matthias and Duba, Bruce},
title = {Hygienic Macro Expansion},
year = {1986},
isbn = {0897912004},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/319838.319859},
doi = {10.1145/319838.319859},
booktitle = {Proceedings of the 1986 ACM Conference on LISP and Functional Programming},
pages = {151–161},
numpages = {11},
location = {Cambridge, Massachusetts, USA},
series = {LFP '86}
}